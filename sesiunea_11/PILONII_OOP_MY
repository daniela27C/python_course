## 游늷 OOP - Cei 4 piloni ai programarii orientate pe obiect (OOP)
- Acestia sunt: Mostenire, Polimorfism, Incapsulare, Abstractizare.

## 游늷 Inheritance - Mostenire
- Mostenire = capacitatea unei clase de a deriva sau a mosteni din alta clasa.
1. Clasa de baza (parent class) = clasa din care se mosteneste.
2. Clasa derivata (child class) = clasa care mosteneste/deriva din clasa parinte.
- Clasa copil va mosteni/va avea acces la toate proprietatile/atributele si metodele
din clasa parinte.
- De asemenea, clasa copil poate si sa aiba proprietati extra si sa extinda comportamentul
clasei de baza (clasei parinte).

-# Pentru a adauga proprietati noi:
    # 1. Extindem lista de parametrii pe care metoda __init__ ii poate lua.
    # 2. Apelam __init__-ul din clasa parinte, folosindu-ne de super(),
    cu parametrii  necesari pentru clasa parinte.
-# Pentru a extinde metode din clasa parinte:
    # Facem apel la metoda din clasa parinte folosind super()

O clasa copil poate sa mosteneasca un numar nelimitat de clase parinte.

## 游늷 Polymorphism - Polimorfism
- Polimorfism = mai multe forme.
- Cand avem 2 sau mai multe functii (SAU METODE ALE CLASEI) cu acelasi nume
dar au comportament diferit.

## 游늷 Abstraction - Abstractizare
-Metode abstracte/ fara corp/ fara implementare
- O clasa abstracta contine metode abstracte dar si metode cu logica definita.
- O interfata contine doar metode abstracte.
- Aceste clase pot fi mostenite de clasele copii care vor trebui sa scrie
logica metodelor.
- "Dog class implements the Animal interface".
- Clasa parinte e ca o reteta ce trebuie implementata exact asa de catre
toti mostenitorii.

Abstractizare:
Abstractizarea se refer캒 la procesul de a izola anumite caracteristici 탳i comportamente
ale unui obiect 칥n modul cel mai general posibil.
칉n cadrul abstractiz캒rii, se extrag tr캒s캒turi comune din mai multe obiecte 탳i se creeaz캒
o structur캒 comun캒 care s캒 le defineasc캒 comportamentul 탳i caracteristicile esen탵iale.
칉n OOP, se utilizeaz캒 clase 탳i interfe탵e pentru a realiza abstractizarea.
Clas캒 abstract캒:
O clas캒 abstract캒 este o clas캒 care nu poate fi instantiat캒 direct, adic캒 nu po탵i crea
obiecte direct din aceast캒 clas캒.
O clas캒 abstract캒 poate con탵ine at칙t metode cu implementare (metode obi탳nuite), c칙t 탳i
metode abstracte (metode f캒r캒 implementare).
Metodele abstracte sunt definite f캒r캒 a oferi o implementare specific캒 탳i trebuie s캒 fie
implementate 칥n subclasele concrete care mo탳tenesc clasa abstract캒.
Interfa탵캒:
O interfa탵캒 este similar캒 cu o clas캒 abstract캒, dar con탵ine doar metode abstracte,
f캒r캒 niciun corp de metod캒.
칉n mod obi탳nuit, o clas캒 poate implementa mai multe interfe탵e, dar poate extinde
o singur캒 clas캒 abstract캒.
Interfe탵ele sunt utile atunci c칙nd dorim s캒 definim un contract comun pentru mai multe clase,
indiferent de clasa real캒.
Mo탳tenire 탳i implementare:
Mo탳tenirea este un concept prin care o clas캒 poate prelua caracteristicile 탳i comportamentul
 altei clase.
Atunci c칙nd o clas캒 mo탳tene탳te o clas캒 abstract캒 sau implementeaz캒 o interfa탵캒, trebuie
 s캒 implementeze toate metodele abstracte definite 칥n clasa abstract캒 sau interfa탵캒.
Astfel, clasa copil devine responsabil캒 de furnizarea implement캒rii concrete pentru
metodele abstracte.
Exemplu:
S캒 lu캒m un exemplu simplu: presupunem c캒 avem o clas캒 abstract캒 Shape, care con탵ine o
metod캒 abstract캒 calculate_area(). Aceast캒 clas캒 abstract캒 poate fi mo탳tenit캒 de clase
concrete precum Circle 탳i Square, care trebuie s캒 implementeze metoda calculate_area()
칥n func탵ie de form캒.
Pe de alt캒 parte, o interfa탵캒 poate fi definit캒 ca Drawable, care con탵ine o metod캒 abstract캒
draw(). Clasele precum Circle, Square, 탳i Triangle pot implementa aceast캒 interfa탵캒 탳i
s캒 defineasc캒 propria lor logic캒 pentru desenare.
칉n esen탵캒, abstractizarea ne permite s캒 definim structuri 탳i comportamente generale,
care s캒 poat캒 fi apoi specializate 칥n clase concrete, oferind astfel un nivel ridicat
de flexibilitate 탳i extensibilitate 칥n proiectarea 탳i dezvoltarea aplica탵iilor.

-SE FOLOSESTE
from abc import ABC, abstractmethod


## 游늷 Encapsulation - Encapsulare
- Encapsularea este procesul prin care facem datele si comportamentul
dintr-o clasa, sa nu fie accesibile in exteriorul acesteia.
- Pentru asta, facem datele/atributele si/sau metodele PRIVATE.
- Pentru a face un atribut sau o metoda privata, punem _ _ in fata numelui
atributului/metodei.

- Mai exista optiunea de PROTECTED ATTRIBUTES/METHODS.
- Pentru a face atributele/metodele protected, punem un singur _
in fata numelui atributului/metodei.
- Atributele/metodele protected pot fi accesate din exterior.
- Protected este doar o conventie prin care putem informa ceilalti programatori
ca atributul/metoda nu ar trebui sa fie folosita in afara clasei.

- Encapsularea se foloseste si pentru a nu aglomera optiunile
utilizatorului, ascunzand atributele.
- In loc sa vada toate atributele si metodele, va vedea doar metodele.
- Astfel, pastram codul clean/curat.


## 游늷Getter 탳i setter sunt dou캒 concepte asociate cu accesul 탳i modificarea valorilor
 atributelor 칥n programarea orientat캒 pe obiecte. Acestea sunt utilizate pentru a controla
  accesul la atributele clasei 탳i pentru a asigura o mai mare securitate 탳i modularitate
  칥n cod. Iat캒 o explica탵ie mai detaliat캒 pentru fiecare:

Getter:
Un getter este o metod캒 utilizat캒 pentru a ob탵ine valoarea unui atribut privat al unei clase.
Acesta permite accesul la valoarea atributului din afara clasei, dar 칥ntr-un mod controlat
탳i securizat.
Getterul ofer캒 o interfa탵캒 pentru a citi valoarea atributului, f캒r캒 a permite modificarea
direct캒 a acestuia.
De obicei, un getter este definit cu un prefix get_ urmat de numele atributului
(de exemplu, get_color() pentru a ob탵ine valoarea atributului color).
Setter:
Un setter este o metod캒 utilizat캒 pentru a seta sau actualiza valoarea unui atribut privat
al unei clase.
Acesta permite modificarea valorii atributului din afara clasei, dar 칥ntr-un mod controlat
 탳i securizat.
Setterul ofer캒 o interfa탵캒 pentru a actualiza valoarea atributului, permi탵칙nd validarea 탳i
prelucrarea acesteia 칥nainte de a fi setat캒.
De obicei, un setter este definit cu un prefix set_ urmat de numele atributului
(de exemplu, set_color() pentru a seta valoarea atributului color).

class Person:
    def __init__(self, name, age):
        self.__name = name  # Atribut privat "__name"
        self.__age = age    # Atribut privat "__age"

    # Getter pentru atributul "__name"
    def get_name(self):
        return self.__name

    # Setter pentru atributul "__name"
    def set_name(self, name):
        self.__name = name

    # Getter pentru atributul "__age"
    def get_age(self):
        return self.__age

    # Setter pentru atributul "__age"
    def set_age(self, age):
        if age >= 0:
            self.__age = age
        else:
            print("V칙rsta trebuie s캒 fie un num캒r pozitiv.")

# Cre캒m o instan탵캒 a clasei Person
person1 = Person("John", 30)

# Utiliz캒m getteri pentru a accesa atributele clasei
print("Nume:", person1.get_name())  # Output: Nume: John
print("V칙rst캒:", person1.get_age())  # Output: V칙rst캒: 30

# Utiliz캒m setteri pentru a modifica atributele clasei
person1.set_name("Jane")
person1.set_age(35)

# Afi탳캒m valorile actualizate folosind getteri
print("Noul nume:", person1.get_name())  # Output: Noul nume: Jane
print("Noua v칙rst캒:", person1.get_age())  # Output: Noua v칙rst캒: 35

# 칉ncerc캒m s캒 set캒m o v칙rst캒 negativ캒 (va genera un mesaj de eroare)
person1.set_age(-5)  # Output: V칙rsta trebuie s캒 fie un num캒r pozitiv.


SAU FOLOSIND DECORATORII PROPERTY, COLOG_GETTER, COLOR_SETTER
class CarPy:

    def __init__(self, color):
        self.__color = color

    @property
    def color(self):
        return self.__color

    @color.getter
    def color(self):
        print(f"Getter: Culoarea este {self.__color}")
        return self.__color

    @color.setter
    def color(self, culoare_noua):
        print(f"Setter: Noua culoare este {culoare_noua}")
        self.__color = culoare_noua

    @color.deleter
    def color(self):
        print(f"Deleter: Am sters culoarea")
        self.__color = None

car2 = CarPy('gray')
print(car2.color)

car2.color = 'red'
print(car2.color)

del car2.color
print(car2.color)